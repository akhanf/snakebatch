import snakebids
from snakebids import bids
from pathlib import Path

configfile: workflow.source_path('../config/snakebids.yml')

#set pybids_database_dir to bids/.pybids
#config["pybids_db_dir"]=Path(config["bids_dir"]) / Path('.pybids')

#this adds constraints to the bids naming (not really required for this workflow as is)
wildcard_constraints:  **snakebids.get_wildcard_constraints(config['pybids_inputs'])


inputs = dict()
subj_wildcards = dict()
bids_intersect = dict()

for dataset in config['datasets'].keys():

    # parse bids dataset, using dataGet input wildcards
    inputs[dataset] = snakebids.generate_inputs(        bids_dir=config["datasets"][dataset]['bids_dir'],
        pybids_inputs=config['datasets'][dataset].get("pybids_inputs",config.get('pybids_inputs',None)),
        pybidsdb_dir=config['datasets'][dataset].get("pybids_db_dir",config.get('pybids_db_dir',None)),
        pybidsdb_reset=config['datasets'][dataset].get("pybids_db_reset",config.get('pybids_db_reset',None)),
        derivatives=config['datasets'][dataset].get("derivatives",config.get('derivatives',None)),
        participant_label=config['datasets'][dataset].get("participant_label",config.get('participant_label',None)),
        exclude_participant_label=config['datasets'][dataset].get("exclude_participant_label",config.get('exclude_participant_label',None)))
    

    subj_wildcards[dataset] = inputs[dataset].subj_wildcards

    # get the subjects that have all the bids components (e.g. both t1 and dwi)
    #   we do this by getting the first component, and then filtering with the entities of each additional one..
    comps = list(inputs[dataset].keys())
    bids_intersect[dataset] = inputs[dataset][comps[0]]

    for c in comps[1:]:
        bids_intersect[dataset] = bids_intersect[dataset].filter(**inputs[dataset][c].entities)

 



def get_targets():
    """ final output files are of the form: {dataset}/{app}/{root_folder}/sub-{subject}/ses-{session} """
    targets=list()
    for dataset in config['datasets'].keys():
        for app in config['apps'].keys():
            for root in config['apps'][app]['root_folders']:
                targets.extend(
                            bids_intersect[dataset].expand(
                                    Path(dataset)/Path(app)/Path(
                                        bids(
                                        root=root,
                                        **subj_wildcards[dataset])).parent)
                                        )
                                        
    return targets


rule all:
    input: 
        get_targets()

def get_cmd_retain_outputs_from_tmp(wildcards,resources,output):
    output_files_folders=[]
    for root_folder in config['apps'][wildcards.app]['root_folders']:
        output_files_folders.append(directory(Path(bids(root=root_folder,**subj_wildcards[wildcards.dataset])).parent))
        
    return ' && '.join([f'cp -Rv {resources.tmpdir}/{out} {wildcards.dataset}/{wildcards.app}/{out}' for out in output_files_folders]),

   
    
def get_session_filter(wildcards):
    input_to_filter = config['apps'][wildcards.app]['input_to_filter']
    if 'session' in wildcards._names:
        return f"--filter-{input_to_filter} session={wildcards.session}"
    else:
        return ''


rule get_snakebids_app:
    params:
        url=lambda wildcards: config['apps'][wildcards.app]['url'],
        tag=lambda wildcards: config['apps'][wildcards.app]['tag'],
    output:
        repo=directory("repo_{app}"),
    localrule: True
    shell:
        'git clone {params.url} -b {params.tag} {output.repo}'

def get_sb_container(app):
    if 'container' in config["apps"][app].keys():
        return {'container': f"containers/{app}.sif" }
    else:
        return {}
 
def get_sb_repo(app):
    if 'url' in config["apps"][app].keys():
        return {'repo': 'repo_{app}'}
    else:
        return {}
        
def get_sb_singularity_opts(wildcards):
    if 'url' in config["apps"][wildcards.app].keys():
        return f"--use-singularity --singularity-prefix {config['singularity_prefix']}"
    else:
        return ""



def get_run_cmd(wildcards, input):
    if 'url' in config["apps"][wildcards.app].keys():
        return f"repo_{wildcards.app}/{config['apps'][wildcards.app]['runscript']}",
    elif 'container' in config["apps"][wildcards.app].keys():

        singularity_opts=config["apps"][wildcards.app].get("singularity_opts","")
            
        if 'runscript' in config["apps"][wildcards.app].keys():
            return f"singularity exec {singularity_opts} {input.container} {input.runscript}"
        else:
            return f'singularity run {singularity_opts} {input.container}'
    else:
        return ""


def get_snakebids_opts(wildcards,input,threads):
    if config["apps"][wildcards.app].get('snakebids',False):
        return f"-p --cores {threads} --pybidsdb-dir {input.bids}/.pybids"
    else:
        return ""


for dataset in config['datasets'].keys():

    def get_output_files_folders(app,dataset):
        """ This function is used to select what files to retain, since the 
        app is run on /tmp, and only files listed here will be copied over"""

        output_files_folders=[]
        for root_folder in config['apps'][app]['root_folders']:
            output_files_folders.append(directory(Path(f'{{dataset,{dataset}}}/{{app,{app}}}')/Path(bids(root=root_folder,**subj_wildcards[dataset])).parent))
        return output_files_folders


    for app in config['apps'].keys():

        if 'container' in config['apps'][app].keys():
            rule: 
                name: f"get_container_{app}"
                container: config["apps"][app]['container']
                output: f"containers/{app}.sif"
                localrule: True
                shell:
                    "ln -sv $SINGULARITY_CONTAINER {output}"

        rule:
            name: f"{dataset}_{app}"
            input:
                bids=lambda wildcards: config["datasets"][wildcards.dataset]['bids_dir'],
                **get_sb_repo(app),
                **get_sb_container(app),
            params:
                run_cmd=get_run_cmd,
                app_opts=lambda wildcards: config["apps"][wildcards.app]['opts'],
                singularity_opts=get_sb_singularity_opts,
                retain_outputs_from_tmp=get_cmd_retain_outputs_from_tmp,
                session_filter=get_session_filter,
                snakebids_opts=get_snakebids_opts
            output:
                get_output_files_folders(app,dataset)
            threads: lambda wildcards: config['apps'][wildcards.app]['resources']['cores']
            resources: 
                tmpdir=lambda wildcards: bids(root=config['apps'][wildcards.app]['resources']['tmpdir'],**subj_wildcards[wildcards.dataset],include_subject_dir=False,include_session_dir=False).format(**wildcards),
                mem_mb=lambda wildcards: config['apps'][wildcards.app]['resources']['mem_mb'],
                runtime=lambda wildcards: config['apps'][wildcards.app]['resources']['runtime'],
                gpus=lambda wildcards: config['apps'][wildcards.app]['resources']['gpus']
            shadow: 'minimal' #to avoid polluting working dir
            shell: 
                '{params.run_cmd} {input.bids} {resources.tmpdir} participant '
                '--participant_label {wildcards.subject} {params.session_filter} '
                '{params.snakebids_opts} '
                '{params.app_opts} '
                '{params.singularity_opts} && '
                '{params.retain_outputs_from_tmp}'
            
